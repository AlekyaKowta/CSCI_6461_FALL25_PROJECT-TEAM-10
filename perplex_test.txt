; ===================================================================
; Program 1: Find Closest Number
;
; Description:
; 1. Reads 3 integers from the keyboard (handling negatives).
; 2. Prints each integer back to the console.
; 3. Reads a 4th "search" integer.
; 4. Finds which of the first 3 numbers is closest to the search number.
; 5. Prints the search number and the closest number found.
;
; Registers Used in Main:
; R0: General purpose, pointer setup, subroutine arguments/return values.
; R1: Loop counter
; R3: Used by JSR/RFS for return address.
; X1: ** DATA BASE POINTER ** (Holds 500)
; X2: Used as a pointer for array access (loaded from PTR_1)
; X3: Used in SUB_PRINT_INT for stack
; ===================================================================

        LOC     100           ; Start program at address 100 (decimal)

; --- BOOTSTRAP AND POINTER TABLE ---
; The simulator starts PC at the first loaded address (LOC 2).
; We MUST place a jump instruction here to redirect to START (LOC 102).

        LOC     2
BOOT:
        JMA     0, 3, 1       ; M[2] = Jump Indirect via M[3]
START_ADDR:
        Data    102           ; M[3] = 102 (The address of START)

; --- POINTERS TO DATA SECTION ---
DATA_BASE_VAL:
        Data    500           ; M[4] = 500 (Base address of our data section)
STACK_MEM_ADDR:
        Data    600           ; M[5] = 600 (Base address of our stack)

; --- JUMP/CALL POINTER TABLE (FOR INDIRECT ADDRESSING) ---
; These labels are calculated by Pass 1 and filled in by Pass 2
; The address values here are placeholders; the assembler will fill them.
READ_LOOP_ADDR:
        Data    110           ; M[6] -> READ_LOOP
INIT_ABS_DONE_ADDR:
        Data    140           ; M[7] -> INIT_ABS_DONE
FIND_LOOP_SETUP_ADDR:
        Data    141           ; M[8] -> FIND_LOOP_SETUP
FIND_CLOSEST_LOOP_ADDR:
        Data    144           ; M[9] -> FIND_CLOSEST_LOOP
GET_ABS_DONE_ADDR:
        Data    155           ; M[10] -> GET_ABS_DONE
COMPARE_DIFFS_ADDR:
        Data    156           ; M[11] -> COMPARE_DIFFS
FIND_LOOP_NEXT_ADDR:
        Data    165           ; M[12] -> FIND_LOOP_NEXT
SUB_READ_INT_ADDR:
        Data    183           ; M[13] -> SUB_READ_INT
RINT_LOOP_START_ADDR:
        Data    188           ; M[14] -> RINT_LOOP_START
RINT_FINISH_ADDR:
        Data    217           ; M[15] -> RINT_FINISH
RINT_CHECK_DIGIT_ADDR:
        Data    198           ; M[16] -> RINT_CHECK_DIGIT
RINT_SET_NEG_ADDR:
        Data    214           ; M[17] -> RINT_SET_NEG
RINT_CHECK_UPPER_ADDR:
        Data    203           ; M[18] -> RINT_CHECK_UPPER
RINT_ADD_DIGIT_ADDR:
        Data    208           ; M[19] -> RINT_ADD_DIGIT
RINT_RETURN_ADDR:
        Data    224           ; M[20] -> RINT_RETURN
SUB_PRINT_INT_ADDR:
        Data    228           ; M[21] -> SUB_PRINT_INT
PRINT_ZERO_ADDR:
        Data    266           ; M[22] -> PRINT_ZERO
PRINT_POSITIVE_ADDR:
        Data    242           ; M[23] -> PRINT_POSITIVE
PRINT_PUSH_LOOP_ADDR:
        Data    242           ; M[24] -> PRINT_PUSH_LOOP
PRINT_POP_LOOP_ADDR:
        Data    255           ; M[25] -> PRINT_POP_LOOP
PRINT_DONE_ADDR:
        Data    269           ; M[26] -> PRINT_DONE
SUB_PRINT_CHAR_ADDR:
        Data    272           ; M[27] -> SUB_PRINT_CHAR
SUB_PRINT_STRING_ADDR:
        Data    274           ; M[28] -> SUB_PRINT_STRING
PS_LOOP_ADDR:
        Data    275           ; M[29] -> PS_LOOP
PS_DONE_ADDR:
        Data    282           ; M[30] -> PS_DONE

; --- MAIN PROGRAM ---
        LOC     102           ; Continue program code

START:
        ; --- SETUP BASE POINTERS ---
        ; Load Data Base Pointer (500) into X1
        ; DATA_BASE_VAL is at address 4.
        LDX     1, 4           ; X1 = M[4] = 500

        ; Load Stack Base Address (600) into R0
        ; STACK_MEM_ADDR is at address 5.
        LDR     0, 0, 5        ; R0 = M[5] = 600
        
        ; Init stack pointer for SUB_PRINT_INT
        ; EA = c(X1) + offset = 500 + offset
        ; STACK_PTR is at 523 (Offset 23)
        ; STACK_BASE is at 522 (Offset 22)
        STR     0, 1, 23 ; STACK_PTR = 600. (EA = 500+23 = 523)
        STR     0, 1, 22 ; STACK_BASE = 600. (EA = 500+22 = 522)


        ; --- 1. READ 3 NUMBERS INTO ARRAY ---
        LDA     1, 0, 3        ; R1 = Loop counter
        ; Get address of NUM_ARRAY (500) and store in PTR_1 (506)
        LDA     0, 0, 0        ; R0 = 0 (offset for NUM_ARRAY)
        ; DATA_BASE_VAL is at address 4.
        AMR     0, 0, 4        ; R0 = R0 + c(M[4]) = 500
        STR     0, 1, 6        ; Store 500 in PTR_1 (EA=500+6=506)

READ_LOOP:
        ; Print "Enter number: "
        ; PROMPT_1 is at 524 (Offset 24)
        LDA     0, 1, 24       ; R0 = EA = c(X1)+24 = 524
        ; JSR -> SUB_PRINT_STRING_ADDR (M[28])
        JSR     0, 0, 28, 1    ; JSR indirect via M[28]

        ; Read integer (returns in R0)
        ; JSR -> SUB_READ_INT_ADDR (M[13])
        JSR     0, 0, 13, 1    ; JSR indirect via M[13]

        ; Store R0 into NUM_ARRAY[i]
        LDX     2, 1, 6        ; X2 = c(M[506]) = PTR_1
        STR     0, 2, 0        ; M[c(X2)] = R0

        ; Echo the number back
        ; JSR -> SUB_PRINT_INT_ADDR (M[21])
        JSR     0, 0, 21, 1    ; JSR indirect via M[21]

        ; Print newline
        ; K_NEWLINE is at 512 (Offset 12)
        LDR     0, 1, 12
        ; JSR -> SUB_PRINT_CHAR_ADDR (M[27])
        JSR     0, 0, 27, 1    ; JSR indirect via M[27]

        ; Increment pointer: PTR_1++
        LDR     0, 1, 6        ; R0 = c(PTR_1)
        AIR     0, 1
        STR     0, 1, 6        ; Store in PTR_1

        ; Decrement loop counter and jump
        ; SOB -> READ_LOOP_ADDR (M[6])
        SOB     1, 0, 6, 1     ; R1--, if R1 > 0, jump indirect via M[6]

        ; --- 2. READ SEARCH NUMBER ---
        ; PROMPT_2 is at 534 (Offset 34 - TOO BIG!)
        LDA     0, 1, 31       ; R0 = 531
        AIR     0, 3           ; R0 = 534
        ; JSR -> SUB_PRINT_STRING_ADDR (M[28])
        JSR     0, 0, 28, 1    
        
        ; JSR -> SUB_READ_INT_ADDR (M[13])
        JSR     0, 0, 13, 1    
        ; SEARCH_NUM is at 503 (Offset 3)
        STR     0, 1, 3        ; Save R0 to SEARCH_NUM (EA=500+3=503)
        LDR     0, 1, 12       ; K_NEWLINE
        ; JSR -> SUB_PRINT_CHAR_ADDR (M[27])
        JSR     0, 0, 27, 1    

        ; --- 3. FIND CLOSEST LOGIC ---
        ; Initialize MIN_DIFF and CLOSEST_NUM with the first element
        ; NUM_ARRAY[0] is at 500 (Offset 0)
        LDR     0, 1, 0        ; R0 = NUM_ARRAY[0]
        ; CLOSEST_NUM is at 504 (Offset 4)
        STR     0, 1, 4

        ; R1 = SEARCH_NUM (Offset 3)
        LDR     1, 1, 3
        STR     0, 1, 7        ; TEMP_VAL (Offset 7)
        SMR     1, 1, 7        ; R1 = SEARCH_NUM - NUM_ARRAY[0]

        ; Get ABS(R1) and store in MIN_DIFF
        ; JGE -> INIT_ABS_DONE_ADDR (M[7])
        JGE     1, 0, 7, 1     ; Jump indirect via M[7]
        LDA     0, 0, 0
        STR     1, 1, 7        ; TEMP_VAL (Offset 7)
        SMR     0, 1, 7        ; R0 = 0 - R1
        STR     0, 1, 5        ; MIN_DIFF (Offset 5)
        ; JMA -> FIND_LOOP_SETUP_ADDR (M[8])
        JMA     0, 0, 8, 1     ; Jump indirect via M[8]
INIT_ABS_DONE:
        STR     1, 1, 5        ; MIN_DIFF (Offset 5)

FIND_LOOP_SETUP:
        LDA     1, 0, 2        ; Loop counter for remaining 2 numbers
        ; R0 = &NUM_ARRAY[1] (Address 501)
        LDA     0, 1, 1        ; R0 = EA = c(X1)+1 = 501
        STR     0, 1, 6        ; PTR_1 (Offset 6)

FIND_CLOSEST_LOOP:
        ; R0 = CURRENT_NUM
        LDX     2, 1, 6        ; X2 = c(PTR_1)
        LDR     0, 2, 0        ; R0 = M[c(X2)] (CURRENT_NUM)

        ; R2 = CURRENT_DIFF = SEARCH_NUM - CURRENT_NUM
        LDR     2, 1, 3        ; R2 = SEARCH_NUM (Offset 3)
        STR     0, 1, 7        ; TEMP_VAL (Offset 7)
        SMR     2, 1, 7        ; R2 = R2 - TEMP_VAL
        STR     2, 1, 8        ; TEMP_DIFF (Offset 8)

        ; Get ABS(CURRENT_DIFF) -> store in R2
        ; JGE -> GET_ABS_DONE_ADDR (M[10])
        JGE     2, 0, 10, 1    ; Jump indirect via M[10]
        LDA     0, 0, 0
        SMR     0, 1, 8        ; R0 = 0 - TEMP_DIFF
        STR     0, 1, 9        ; TEMP_ABS_DIFF (Offset 9)
        ; JMA -> COMPARE_DIFFS_ADDR (M[11])
        JMA     0, 0, 11, 1    ; Jump indirect via M[11]
GET_ABS_DONE:
        STR     2, 1, 9        ; TEMP_ABS_DIFF (Offset 9)

COMPARE_DIFFS:
        ; if (CURRENT_ABS_DIFF < MIN_DIFF)
        LDR     2, 1, 9        ; R2 = TEMP_ABS_DIFF
        LDR     0, 1, 5        ; R0 = MIN_DIFF
        STR     0, 1, 7        ; TEMP_VAL
        SMR     2, 1, 7        ; R2 = TEMP_ABS_DIFF - MIN_DIFF
        ; JGE -> FIND_LOOP_NEXT_ADDR (M[12])
        JGE     2, 0, 12, 1    ; If >= 0, not smaller. Skip.

        ; Update: MIN_DIFF = CURRENT_ABS_DIFF
        LDR     2, 1, 9
        STR     2, 1, 5        ; MIN_DIFF (Offset 5)
        ; Update: CLOSEST_NUM = CURRENT_NUM
        LDR     0, 2, 0        ; R0 = M[c(X2)] (CURRENT_NUM)
        STR     0, 1, 4        ; CLOSEST_NUM (Offset 4)

FIND_LOOP_NEXT:
        ; Increment pointer
        LDR     0, 1, 6        ; R0 = c(PTR_1)
        AIR     0, 1
        STR     0, 1, 6        ; Store in PTR_1
        ; Decrement loop counter and jump
        ; SOB -> FIND_CLOSEST_LOOP_ADDR (M[9])
        SOB     1, 0, 9, 1     ; Jump indirect via M[9]

        ; --- 4. PRINT RESULTS ---
        ; PROMPT_3 is at 551 (Offset 51 - TOO BIG!)
        LDA     0, 1, 31       ; R0 = 531
        AIR     0, 20          ; R0 = 551
        ; JSR -> SUB_PRINT_STRING_ADDR (M[28])
        JSR     0, 0, 28, 1
        
        LDR     0, 1, 3        ; R0 = SEARCH_NUM
        ; JSR -> SUB_PRINT_INT_ADDR (M[21])
        JSR     0, 0, 21, 1

        ; PROMPT_4 is at 564 (Offset 64 - TOO BIG!)
        LDA     0, 1, 31       ; R0 = 531
        AIR     0, 31          ; R0 = 562
        AIR     0, 2           ; R0 = 564
        ; JSR -> SUB_PRINT_STRING_ADDR (M[28])
        JSR     0, 0, 28, 1

        LDR     0, 1, 4        ; R0 = CLOSEST_NUM
        ; JSR -> SUB_PRINT_INT_ADDR (M[21])
        JSR     0, 0, 21, 1

        LDR     0, 1, 12       ; K_NEWLINE
        ; JSR -> SUB_PRINT_CHAR_ADDR (M[27])
        JSR     0, 0, 27, 1

        ; --- 5. HALT ---
        HLT

; ===================================================================
; SUBROUTINE: SUB_READ_INT
; Reads a signed integer from the keyboard (Dev 0).
; Returns: R0 = Assembled integer
; Destroys: R0, R1, R2
; Base Ptr: X1 must hold 500
; ===================================================================
SUB_READ_INT:
        ; Save registers (R3 is already saved by JSR)
        ; RINT_R1 (Offset 17), RINT_R2 (Offset 18)
        STR     1, 1, 17
        STR     2, 1, 18

        LDA     0, 0, 0
        STR     0, 1, 15       ; RINT_TOTAL (Offset 15)
        STR     0, 1, 16       ; RINT_ISNEG (Offset 16)

RINT_LOOP_START:
        IN      2, 0           ; R2 = char
        OUT     2, 1           ; Echo char

        ; Check for newline (end)
        LDR     0, 1, 12       ; K_NEWLINE (Offset 12)
        TRR     2, 0
        ; JCC -> RINT_FINISH_ADDR (M[15])
        JCC     3, 0, 15, 1    ; If (R2 == R0), JCC 3 (EQUALORNOT)

        ; Check for minus sign (only at start)
        LDR     0, 1, 15       ; RINT_TOTAL
        ; JNE -> RINT_CHECK_DIGIT_ADDR (M[16])
        JNE     0, 0, 16, 1    ; If total != 0, not at start.
        LDR     0, 1, 13       ; K_MINUS (Offset 13)
        TRR     2, 0
        ; JCC -> RINT_SET_NEG_ADDR (M[17])
        JCC     3, 0, 17, 1    ; If equal, set neg flag

RINT_CHECK_DIGIT:
        ; Convert char to digit: R2 = R2 - '0'
        LDR     0, 1, 11       ; K_ZERO (Offset 11)
        STR     0, 1, 7        ; TEMP_VAL (Offset 7)
        SMR     2, 1, 7
        ; Check bounds (0-9)
        ; JGE -> RINT_CHECK_UPPER_ADDR (M[18])
        JGE     2, 0, 18, 1    ; If R2 >= 0, it's >= '0'
        ; JMA -> RINT_LOOP_START_ADDR (M[14])
        JMA     0, 0, 14, 1    ; Not a digit, ignore
RINT_CHECK_UPPER:
        LDA     0, 0, 9
        STR     2, 1, 7        ; TEMP_VAL
        SMR     0, 1, 7        ; R0 = 9 - digit_val
        ; JGE -> RINT_ADD_DIGIT_ADDR (M[19])
        JGE     0, 0, 19, 1    ; If >= 0, it's <= 9
        ; JMA -> RINT_LOOP_START_ADDR (M[14])
        JMA     0, 0, 14, 1    ; Not a digit, ignore

RINT_ADD_DIGIT:
        ; total = (total * 10)
        LDR     0, 1, 15       ; R0 = RINT_TOTAL
        LDR     2, 1, 10       ; R2 = K_TEN (Offset 10)
        MLT     0, 2           ; R0,R1 = R0*R2. Low bits in R1.
        ; + digit (which is in TEMP_VAL)
        AMR     1, 1, 7        ; R1 = (total*10) + digit
        STR     1, 1, 15       ; Save new total
        ; JMA -> RINT_LOOP_START_ADDR (M[14])
        JMA     0, 0, 14, 1

RINT_SET_NEG:
        LDA     0, 0, 1
        STR     0, 1, 16       ; RINT_ISNEG = 1
        ; JMA -> RINT_LOOP_START_ADDR (M[14])
        JMA     0, 0, 14, 1

RINT_FINISH:
        LDR     1, 1, 16       ; R1 = RINT_ISNEG
        ; JZ -> RINT_RETURN_ADDR (M[20])
        JZ      1, 0, 20, 1    ; If is_neg == 0, return
        ; Negate total
        LDR     0, 1, 15       ; R0 = RINT_TOTAL
        LDA     2, 0, 0
        STR     0, 1, 7        ; TEMP_VAL
        SMR     2, 1, 7        ; R2 = 0 - total
        STR     2, 1, 15       ; RINT_TOTAL

RINT_RETURN:
        LDR     0, 1, 15       ; Load return value into R0 (for main)
        LDR     1, 1, 17       ; Restore R1
        LDR     2, 1, 18       ; Restore R2
        RFS     0              ; Return (PC <- c(R3))

; ===================================================================
; SUBROUTINE: SUB_PRINT_INT
; Prints a signed integer (from R0) to the console (Dev 1).
; Args: R0 = Number to print
; Destroys: R0, R1, R2, X3
; Base Ptr: X1 must hold 500
; ===================================================================
SUB_PRINT_INT:
        STR     0, 1, 19       ; PRINT_VAL (Offset 19)
        STR     1, 1, 20       ; PRINT_R1 (Offset 20)
        STR     2, 1, 21       ; PRINT_R2 (Offset 21)
        LDX     3, 1, 22       ; X3 = c(STACK_BASE) (Offset 22)
        STR     3, 1, 23       ; STACK_PTR = c(STACK_BASE) (Offset 23)

        ; Check if R0 == 0
        ; JZ -> PRINT_ZERO_ADDR (M[22])
        JZ      0, 0, 22, 1
        ; Check if R0 < 0
        ; JGE -> PRINT_POSITIVE_ADDR (M[23])
        JGE     0, 0, 23, 1
        
        ; Is negative
        LDR     0, 1, 13       ; K_MINUS (Offset 13)
        OUT     0, 1           ; Print '-'
        ; Negate value
        LDR     0, 1, 19       ; PRINT_VAL
        LDA     2, 0, 0
        STR     0, 1, 7        ; TEMP_VAL (Offset 7)
        SMR     2, 1, 7        ; R2 = 0 - value
        STR     2, 1, 19       ; PRINT_VAL

PRINT_POSITIVE:
        ; Use divide to push digits onto stack
PRINT_PUSH_LOOP:
        LDR     0, 1, 19       ; R0 = PRINT_VAL
        ; JZ -> PRINT_POP_LOOP_ADDR (M[25])
        JZ      0, 0, 25, 1    ; If num == 0, done pushing
        LDR     2, 1, 10       ; K_TEN (Offset 10)
        DVD     0, 2           ; R0=quotient, R1=remainder
        STR     0, 1, 19       ; num = quotient
        
        ; Convert remainder to char: R1 = R1 + '0'
        LDR     0, 1, 11       ; K_ZERO (Offset 11)
        STR     1, 1, 7        ; TEMP_VAL (Offset 7)
        AMR     0, 1, 7        ; R0 = remainder + '0'

        ; Push char to stack
        LDX     3, 1, 23       ; X3 = c(STACK_PTR)
        STR     0, 3, 0        ; M[c(X3)] = char
        ; STACK_PTR++
        AIR     3, 1
        STR     3, 1, 23       ; Store new STACK_PTR
        ; JMA -> PRINT_PUSH_LOOP_ADDR (M[24])
        JMA     0, 0, 24, 1

PRINT_POP_LOOP:
        ; while (STACK_PTR > STACK_BASE)
        LDX     3, 1, 23       ; X3 = c(STACK_PTR)
        LDR     0, 1, 22       ; R0 = c(STACK_BASE)
        STR     0, 1, 7        ; TEMP_VAL
        SMR     3, 1, 7        ; R0 = STACK_PTR - STACK_BASE
        ; JZ -> PRINT_DONE_ADDR (M[26])
        JZ      3, 0, 26, 1    ; If 0, stack empty

        ; STACK_PTR--
        LDX     3, 1, 23
        SIR     3, 1
        STR     3, 1, 23
        
        ; Pop and print
        LDR     0, 3, 0        ; R0 = M[c(X3)] (char)
        OUT     0, 1
        ; JMA -> PRINT_POP_LOOP_ADDR (M[25])
        JMA     0, 0, 25, 1

PRINT_ZERO:
        LDR     0, 1, 11       ; K_ZERO (Offset 11)
        OUT     0, 1
        ; JMA -> PRINT_DONE_ADDR (M[26])
        JMA     0, 0, 26, 1

PRINT_DONE:
        LDR     1, 1, 20       ; PRINT_R1
        LDR     2, 1, 21       ; PRINT_R2
        RFS     0

; ===================================================================
; SUBROUTINE: SUB_PRINT_CHAR
; Prints a single char (from R0) to the console (Dev 1).
; Args: R0 = Char to print
; ===================================================================
SUB_PRINT_CHAR:
        OUT     0, 1
        RFS     0

; ===================================================================
; SUBROUTINE: SUB_PRINT_STRING
; Prints a null-terminated string.
; Args: R0 = Address of string
; Destroys: R0, R1, X2
; Base Ptr: X1 must hold 500
; ===================================================================
SUB_PRINT_STRING:
        STR     0, 1, 6        ; PTR_1 (Offset 6)
PS_LOOP:
        LDX     2, 1, 6        ; X2 = string pointer
        LDR     1, 2, 0        ; R1 = char
        ; JZ -> PS_DONE_ADDR (M[30])
        JZ      1, 0, 30, 1    ; If char == 0, return
        OUT     1, 1           ; Print char
        ; Increment pointer
        LDR     0, 1, 6
        AIR     0, 1
        STR     0, 1, 6
        ; JMA -> PS_LOOP_ADDR (M[29])
        JMA     0, 0, 29, 1
PS_DONE:
        RFS     0

; ===================================================================
; --- DATA SECTION ---
; Base Address is 500 (Loaded into X1 at START)
; ===================================================================
        LOC     500           ; Start data section at 500

; --- Program Data (Offsets 0-5) ---
NUM_ARRAY:
        Data    0             ; 500 (Offset 0)
        Data    0             ; 501 (Offset 1)
        Data    0             ; 502 (Offset 2)
SEARCH_NUM:
        Data    0             ; 503 (Offset 3)
CLOSEST_NUM:
        Data    0             ; 504 (Offset 4)
MIN_DIFF:
        Data    0             ; 505 (Offset 5)

; --- Pointers and Temp Storage (Offsets 6-9) ---
PTR_1:
        Data    0             ; 506 (Offset 6)
TEMP_VAL:
        Data    0             ; 507 (Offset 7)
TEMP_DIFF:
        Data    0             ; 508 (Offset 8)
TEMP_ABS_DIFF:
        Data    0             ; 509 (Offset 9)

; --- Constants (Offsets 10-14) ---
K_TEN:
        Data    10            ; 510 (Offset 10)
K_ZERO:
        Data    48            ; 511 (Offset 11)
K_NEWLINE:
        Data    10            ; 512 (Offset 12)
K_MINUS:
        Data    45            ; 513 (Offset 13)
K_SPACE:
        Data    32            ; 514 (Offset 14)

; --- Subroutine Storage (Offsets 15-23) ---
RINT_TOTAL:
        Data    0             ; 515 (Offset 15)
RINT_ISNEG:
        Data    0             ; 516 (Offset 16)
RINT_R1:
        Data    0             ; 517 (Offset 17)
RINT_R2:
        Data    0             ; 518 (Offset 18)
PRINT_VAL:
        Data    0             ; 519 (Offset 19)
PRINT_R1:
        Data    0             ; 520 (Offset 20)
PRINT_R2:
        Data    0             ; 521 (Offset 21)
STACK_BASE:
        Data    0             ; 522 (Offset 22)
STACK_PTR:
        Data    0             ; 523 (Offset 23)

; --- Strings (Null-terminated) (Offsets 24+) ---
PROMPT_1:                       ; 524 (Offset 24)
        Data    69            ; E
        Data    110           ; n
        Data    116           ; t
        Data    101           ; e
        Data    114           ; r
        Data    32            ;
        Data    35            ; #
        Data    58            ; :
        Data    32            ;
        Data    0             ; Null (Offset 33)
PROMPT_2:                       ; 534 (Offset 34)
        Data    69            ; E
        Data    110           ; n
        Data    116           ; t
        Data    101           ; e
        Data    114           ; r
        Data    32            ;
        Data    115           ; s
        Data    101           ; e
        Data    97            ; a
        Data    114           ; r
        Data    99            ; c
        Data    104           ; h
        Data    32            ;
        Data    35            ; #
        Data    58            ; :
        Data    32            ;
        Data    0             ; Null (Offset 50)
PROMPT_3:                       ; 551 (Offset 51)
        Data    83            ; S
        Data    101           ; e
        Data    97            ; a
        Data    114           ; r
        Data    99            ; c
        Data    104           ; h
        Data    32            ;
        Data    110           ; n
        Data    117           ; u
        Data    109           ; m
        Data    58            ; :
        Data    32            ;
        Data    0             ; Null (Offset 63)
PROMPT_4:                       ; 564 (Offset 64)
        Data    44            ; ,
        Data    32            ;
        Data    67            ; C
        Data    108           ; l
        Data    111           ; o
        Data    105           ; s
        Data    101           ; e
        Data    115           ; s
        Data    116           ; t
        Data    58            ; :
        Data    32            ;
        Data    0             ; Null (Offset 75)
        
        LOC     600           ; Start stack memory
STACK_MEM:
        Data    0
        ; ... stack grows up from here

