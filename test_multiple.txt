; ===== Low memory (6..31) =====
LOC 6
NUM1:      Data 0
NUM2:      Data 0
NUM3:      Data 0
TARGET:    Data 0
DIFF1:     Data 0
DIFF2:     Data 0
DIFF3:     Data 0
CURVAL:    Data 0
CURDIFF:   Data 0
TMP:       Data 0

; Indirect jump targets (keep Address fields â‰¤31)
P_POS1:    Data POS1
P_POS2:    Data POS2
P_POS3:    Data POS3
P_AFTER1:  Data AFTER1
P_AFTER2:  Data AFTER2

; ===== Code (decimal 256 so start is octal 0400) =====
LOC 256

AIR 0,1

; read three digits, discard newline each time
IN 0,0
STR 0,0,NUM1
IN 0,0
IN 0,0
STR 0,0,NUM2
IN 0,0
IN 0,0
STR 0,0,NUM3
IN 0,0

; echo them
LDR 0,0,NUM1
OUT 0,1
LDR 0,0,NUM2
OUT 0,1
LDR 0,0,NUM3
OUT 0,1

; read target, discard newline
IN 0,0
STR 0,0,TARGET
IN 0,0

; abs(NUM1 - TARGET) -> DIFF1
LDR 1,0,NUM1
SMR 1,0,TARGET
JGE 1,0,P_POS1,1
NOT 1
AIR 1,1
POS1:
STR 1,0,DIFF1

; abs(NUM2 - TARGET) -> DIFF2
LDR 1,0,NUM2
SMR 1,0,TARGET
JGE 1,0,P_POS2,1
NOT 1
AIR 1,1
POS2:
STR 1,0,DIFF2

; abs(NUM3 - TARGET) -> DIFF3
LDR 1,0,NUM3
SMR 1,0,TARGET
JGE 1,0,P_POS3,1
NOT 1
AIR 1,1
POS3:
STR 1,0,DIFF3

; init best = NUM1 / DIFF1
LDR 0,0,NUM1
STR 0,0,CURVAL
LDR 3,0,DIFF1
STR 3,0,CURDIFF

; compare DIFF2 vs CURDIFF
STR 3,0,TMP
LDR 1,0,DIFF2
SMR 1,0,TMP
JGE 1,0,P_AFTER1,1
LDR 0,0,NUM2
STR 0,0,CURVAL
LDR 3,0,DIFF2
STR 3,0,CURDIFF
JMA 0,P_AFTER1,1

; compare DIFF3 vs CURDIFF
AFTER1:
STR 3,0,TMP
LDR 1,0,DIFF3
SMR 1,0,TMP
JGE 1,0,P_AFTER2,1
LDR 0,0,NUM3
STR 0,0,CURVAL
LDR 3,0,DIFF3
STR 3,0,CURDIFF
JMA 0,P_AFTER2,1

; print target and closest
AFTER2:
LDR 0,0,TARGET
OUT 0,1
LDR 0,0,CURVAL
OUT 0,1

HLT
