; ===== C461 Assembler Program =====
; Program 1, Step 2
; Reads 3 full-range integers (-32768 to 32767)
; Reads 1 target integer.
; Finds and prints the number closest to the target.

; ===== Low memory (Data, 0-31) =====
LOC 6
NUM1:      Data 0
NUM2:      Data 0
NUM3:      Data 0
TARGET:    Data 0
DIFF1:     Data 0
DIFF2:     Data 0
DIFF3:     Data 0
CURVAL:    Data 0
CURDIFF:   Data 0
TMP:       Data 0       ; Location 15 (if all above are 1 word)

; READINT Data
RET_ADDR:   Data 0
TMP2:       Data 0
TMP3:       Data 0      ; Location 18 (used by SMR in READINT fix)
SIGN_MEM:   Data 0
TMP_DIGIT:  Data 0
ACCUM_MULT: Data 0
ZERO:       Data 0
ONE:        Data 1
NEGONE:     Data 0
TEN:        Data 10
NEWLINE:    Data 10     ; Location 27

; Main Logic Jumps
P_POS1:    Data POS1
P_POS2:    Data POS2
P_POS3:    Data POS3
P_AFTER1:  Data AFTER1
P_AFTER2:  Data AFTER2


; ===== Extended Data (32+) =====
; This data is accessed using X1 as a base register
LOC 32
D_MINUS:       Data 45 ; Offset 0
D_ASCII_ZERO:  Data 48 ; Offset 1
D_P_READINT:   Data READINT        ; Offset 2
D_P_RESTORE:   Data RESTORE_AND_LOOP ; Offset 3
D_P_DIGIT_LOOP:Data DIGIT_LOOP     ; Offset 4
D_P_END_READINT: Data END_READINT    ; Offset 5


; ===== Code (Starts at 256) =====
LOC 256

; --- Main Program Logic ---

; --- BOOTSTRAP: Load 32 into X1 and -1 into NEGONE ---
; We need to access memory > 31.
; 1. Load X1 = 32
LDR 1, 0, ZERO         ; R1 = 0
AIR 1, 31              ; R1 = 31
AIR 1, 1               ; R1 = 32
STR 1, 0, TMP          ; Store 32 into TMP (loc 15)
LDX 1, TMP             ; Load X1 from TMP. X1 now = 32

; 2. Create -1 and store in NEGONE
LDR 1, 0, ZERO         ; R1 = 0
SIR 1, 1               ; R1 = 0 - 1 (R1 is now -1)
STR 1, 0, NEGONE       ; Store -1 into the NEGONE data location

; Read three full integers
JSR 0, 1, 2, 1  ; Call READINT (x=1, address=2, i=1)
STR 0, 0, NUM1    ; Store R0 into NUM1

JSR 0, 1, 2, 1  ; Call READINT (x=1, address=2, i=1)
STR 0, 0, NUM2

JSR 0, 1, 2, 1  ; Call READINT (x=1, address=2, i=1)
STR 0, 0, NUM3

; echo them
LDR 0, 0, NUM1
OUT 0, 1
LDR 0, 0, NUM2
OUT 0, 1
LDR 0, 0, NUM3
OUT 0, 1

; read target
JSR 0, 1, 2, 1  ; Call READINT (x=1, address=2, i=1)
STR 0, 0, TARGET

; abs(NUM1 - TARGET) -> DIFF1
LDR 1, 0, NUM1
SMR 1, 0, TARGET
JGE 1, 0, P_POS1, 1
NOT 1
AIR 1, 1
POS1:
STR 1, 0, DIFF1

; abs(NUM2 - TARGET) -> DIFF2
LDR 1, 0, NUM2
SMR 1, 0, TARGET
JGE 1, 0, P_POS2, 1
NOT 1
AIR 1, 1
POS2:
STR 1, 0, DIFF2

; abs(NUM3 - TARGET) -> DIFF3
LDR 1, 0, NUM3
SMR 1, 0, TARGET
JGE 1, 0, P_POS3, 1
NOT 1
AIR 1, 1
POS3:
STR 1, 0, DIFF3

; init best = NUM1 / DIFF1
LDR 0, 0, NUM1
STR 0, 0, CURVAL
LDR 3, 0, DIFF1
STR 3, 0, CURDIFF

; compare DIFF2 vs CURDIFF
STR 3, 0, TMP
LDR 1, 0, DIFF2
SMR 1, 0, TMP
JGE 1, 0, P_AFTER1, 1
LDR 0, 0, NUM2
STR 0, 0, CURVAL
LDR 3, 0, DIFF2
STR 3, 0, CURDIFF
JMA 0, P_AFTER1, 1

; compare DIFF3 vs CURDIFF
AFTER1:
STR 3, 0, TMP
LDR 1, 0, DIFF3
SMR 1, 0, TMP
JGE 1, 0, P_AFTER2, 1
LDR 0, 0, NUM3
STR 0, 0, CURVAL
LDR 3, 0, DIFF3
STR 3, 0, CURDIFF
JMA 0, P_AFTER2, 1

; print target and closest
AFTER2:
LDR 0, 0, TARGET
OUT 0, 1
LDR 0, 0, CURVAL
OUT 0, 1

HLT ; End of main program

; ===== Subroutine: READINT (Final working logic) =====
; Reads a signed, multi-digit integer from keyboard (DEVID 0)
; Returns the final 16-bit integer in R0
; Clobbers R0, R1, R2, R3
; Assumes X1 = 32 (Base for extended data)
READINT:
    STR 3, 0, RET_ADDR  ; Save return address (R3)
    LDR 0, 0, ZERO      ; R0 = 0 (This is our accumulator)
    LDR 1, 0, ONE       ; R1 = 1 (This is our sign flag)
    IN 2, 0             ; Read first character into R2
    OUT 2, 1            ; Echo character

    ; Check if first char is '-'
    LDR 3, 1, 0         ; Load ASCII 45 (Offset 0 from X1)
    STR 2, 0, TMP       ; Save char (R2)
    STR 3, 0, TMP3      ; Store c(R3) to memory (TMP3)
    SMR 2, 0, TMP3      ; R2 = c(R2) - c(TMP3). R2 is 0 if char was '-'.

    JNE 2, 1, 3, 1 ; Jump to RESTORE_AND_LOOP (offset 3) if R2 != 0

    ; It WAS a minus
    LDR 1, 0, NEGONE    ; Set sign flag R1 = -1
    IN 2, 0             ; Read the *next* char (first digit)
    OUT 2, 1            ; Echo
    JMA 0, 1, 4, 1 ; Jump to DIGIT_LOOP (offset 4)

RESTORE_AND_LOOP:
    LDR 2, 0, TMP       ; Restore original digit char into R2

DIGIT_LOOP:
    ; Check if char in R2 is newline
    LDR 3, 0, NEWLINE   ; R3 = 10
    STR 2, 0, TMP       ; Save char (R2)
    STR 3, 0, TMP3      ; Store c(R3) to memory (TMP3)
    SMR 2, 0, TMP3      ; R2 = c(R2) - c(TMP3). R2 is 0 if char was newline.

    JZ 2, 1, 5, 1 ; Jump to END_READINT (offset 5) if R2 == 0

    LDR 2, 0, TMP       ; Restore char (R2) *only if not a newline*

    ; It's a digit. Convert ASCII to value
    LDR 3, 1, 1          ; Load ASCII 48 (Offset 1 from X1)
    STR 3, 0, TMP3       ; Store c(R3) to memory (TMP3)
    SMR 2, 0, TMP3       ; R2 = R2 - 48 (R2 now holds digit value 0-9)

    ; Accumulate: R0 = (R0 * 10) + R2
    STR 0, 0, TMP       ; Save R0 (current accum)
    STR 1, 0, TMP2      ; Save R1 (sign flag)
    STR 2, 0, TMP_DIGIT ; Save R2 (digit value)

    LDR 0, 0, TMP       ; Load accum into R0 for MLT
    LDR 2, 0, TEN       ; Load 10 into R2 for MLT
    MLT 0, 2            ; R0,R1 = R0 * R2. Result (R0*10) is in R1 (low bits)

    STR 1, 0, ACCUM_MULT ; Store R1 (which is accum * 10)
    LDR 0, 0, ACCUM_MULT ; Load (accum * 10) into R0
    AMR 0, 0, TMP_DIGIT  ; R0 = R0 + digit value. R0 is now new accumulator.

    LDR 1, 0, TMP2      ; Restore R1 (sign flag)

    ; Read next char and loop
    IN 2, 0
    OUT 2, 1

    ; *** FINAL, GUARANTEED FIX: Use JNE instead of JMA ***
    ; R0 holds the positive accumulated value (e.g., 2 for input '2'). R0 is NOT ZERO.
    ; This jump is guaranteed to execute and uses the known-good 4-argument format.
    JNE 0, 1, 4, 1 ; Jump to DIGIT_LOOP (offset 4)

END_READINT:
    ; R0 has the final positive number
    ; R1 has the sign (1 or -1)
    ; Apply sign: R0 = R0 * R1
    STR 1, 0, SIGN_MEM  ; Store sign
    LDR 2, 0, SIGN_MEM  ; Load sign into R2 for MLT
    MLT 0, 2            ; R0,R1 = R0 * R2. Final result in R1

    STR 1, 0, TMP       ; Store final signed value
    LDR 0, 0, TMP       ; Load final value into R0 (return value)

    LDR 3, 0, RET_ADDR  ; Restore R3 (return address)
    RFS 0               ; Return From Subroutine