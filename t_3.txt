; CSCI 6461 — Program 1 (starter): 3-number version, ISA-compliant within 0..31 address range
; Goal: Find the closest of three signed 16-bit integers (N0,N1,N2) to QUERY.
; Strict constraints:
;  - No floating point.
;  - Only integer opcodes from the ISA.
;  - All labels/data placed so effective addresses stay within the assembler’s 5-bit Address field (0..31).
;  - No assumptions about keyboard/ASCII yet.
;
; Registers used (R0–R3):
;   R0: current number (Ni)
;   R1: current distance |Ni - QUERY|
;   R2: best distance so far
;   R3: best value so far
;
; Absolute value is implemented without NOT: if (Ni-QUERY) < 0 then compute (QUERY-Ni).
; Compare uses: (bestdist - currentdist) >= 0 ? take new : keep old.
;
            LOC     0           ; keep everything inside addresses 0..31 to satisfy 5-bit Address field

; -------- Initialize with N0 --------
START:      LDR     0,0,N0      ; R0 <- N0
            LDR     1,0,N0      ; R1 <- N0
            SMR     1,0,QUERY   ; R1 <- N0 - QUERY
            JGE     1,0,ABS0_OK ; if >=0, R1 is already |N0-QUERY|
            LDR     1,0,QUERY   ; else R1 <- QUERY
            SMR     1,0,N0      ; R1 <- QUERY - N0  (now |N0-QUERY|)
ABS0_OK:    LDR     3,0,N0      ; R3 <- best value = N0
            LDR     2,0,R1MEM   ; R2 <- (garbage initially)
            STR     1,0,R1MEM   ; R1MEM <- |N0-QUERY|
            LDR     2,0,R1MEM   ; R2 <- bestdist = |N0-QUERY|

; -------- Consider N1 --------
N1_STEP:    LDR     0,0,N1      ; R0 <- N1
            LDR     1,0,N1      ; R1 <- N1
            SMR     1,0,QUERY   ; R1 <- N1 - QUERY
            JGE     1,0,ABS1_OK ; if >=0 keep
            LDR     1,0,QUERY   ; R1 <- QUERY
            SMR     1,0,N1      ; R1 <- QUERY - N1 (abs)
ABS1_OK:    LDR     2,0,BESTDIST; R2 <- bestdist
            SMR     2,0,R1MEM   ; R2 <- bestdist - (old R1MEM) [clear path]
            LDR     2,0,BESTDIST; R2 <- bestdist
            SMR     2,0,R1      ; R2 <- bestdist - |N1-QUERY|
            JGE     2,0,TAKE_N1 ; if >=0, take N1
            JMA     0,CONT_N2   ; else continue
TAKE_N1:    STR     1,0,BESTDIST; bestdist <- |N1-QUERY|
            STR     0,0,BEST    ; best <- N1

; -------- Consider N2 --------
CONT_N2:    LDR     0,0,N2      ; R0 <- N2
            LDR     1,0,N2      ; R1 <- N2
            SMR     1,0,QUERY   ; R1 <- N2 - QUERY
            JGE     1,0,ABS2_OK
            LDR     1,0,QUERY   ; R1 <- QUERY
            SMR     1,0,N2      ; R1 <- QUERY - N2
ABS2_OK:    LDR     2,0,BESTDIST; R2 <- bestdist
            SMR     2,0,R1      ; R2 <- bestdist - |N2-QUERY|
            JGE     2,0,TAKE_N2 ; if >=0, take N2
            JMA     0,DONE
TAKE_N2:    STR     1,0,BESTDIST; bestdist <- |N2-QUERY|
            STR     0,0,BEST    ; best <- N2

DONE:       HLT                 ; results in BEST and BESTDIST

; -------- Data (kept compact to stay under address 32) --------
N0:         Data    -12345      ; input #1 (edit as needed)
N1:         Data     23456      ; input #2
N2:         Data    -300        ; input #3
QUERY:      Data     2000       ; query value
BEST:       Data     0          ; output: closest value
BESTDIST:   Data     0          ; output: |closest - QUERY|
R1MEM:      Data     0          ; temp mirror for R1 when needed
